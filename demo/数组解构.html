<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>数组解构赋值</title>
</head>
<body>
	<script type="text/javascript">
/*
		let [a,[[b],c]] = [1,[[22],3]];
		console.log(a);				//1
		console.log(b);				//22
		console.log(c);				//3

		let [x,,y] = [1.1,2.2,3.3];
		console.log(x);			//1.1
		console.log(y);			//3.3

		//rest参数必须放在最后
		let [head, ...tail] = [1,2,3,4,5];
		console.log(head);			//1
		console.log(tail);			//[2,3,4,5]
*/

// 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。


/*
		// 递归-斐波那契数列
		function* fibs(){	
				//构造一个生成器函数
			let a = 0;
			let b = 1;
			while(true){
				yield a;					//yield 关键字用来暂停和继续执行一个生成器函数。
				[a,b] = [b,a+b];
			}
		}
		let [one,two,three,four,fifer,six] = fibs();
		console.log(six);
*/


/*a
		// 解构赋值允许指定默认值。
		let [a,b="Sha"] = ["da"];
		console.log(a);				//da
		console.log(b);				//Sha
*/

/*
		let [x = 1, y = x] = [];     // x=1; y=1
		let [x = 1, y = x] = [2];    // x=2; y=2
		let [x = 1, y = x] = [1,2]; // x=1; y=2
		let [x = y, y = 1] = [];     //报错， ReferenceError
*/

/*
		// 如果变量名与属性名不一致，必须写成下面这样。
		//对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。
		let obj = {first:"da",last:"Sha"};
		let {first:f,last:l} = obj;
		// console.log(first);		//first is undified
		console.log(f);				//da
		console.log(l);				//Sha
*/



		//解构也可以用于嵌套结构的对象
		let obj = {
			p:[
				"hello",
				{y:"world"}
			]
		};
		// let {p:[x,{y}]} = obj;
		// 这时p是模式，不是变量，因此不会被赋值
		let {p,p:[x,{y}]} = obj;
		console.log(x);
		console.log(y);
		console.log(p);				//["Hello", {y: "World"}]
		


	</script>
</body>
</html>
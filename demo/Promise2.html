<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Promise的操作</title>
</head>
<body>
	<script type="text/javascript">
/*
		// 一个异步操作的结果是返回另一个异步操作。
		const p1 = new Promise(function(resolve,reject){
			setTimeout(()=> reject(new Error('fail')),3000);
		});
		const p2 = new Promise(function(resolve,reject){
			setTimeout(()=>resolve(p1),1000);					//由p1的状态决定p2的状态
		});
		p2
			.then(result=>console.log(result))
			.catch(error=>console.log(error));				//Error: fail
		
		// 上面代码中，p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。
*/		


		
		const p3 = new Promise(function(resolve,reject){
			resolve(1);					//若改写为 return resolve(1) 后面的console.log(2)不会执行
			console.log(2);
		}).then(r => console.log(r));
		// 2
		// 1
		// 上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。
	</script>
</body>
</html>